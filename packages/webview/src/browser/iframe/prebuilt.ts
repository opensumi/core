/* prettier-ignore */
/* eslint-disable arrow-body-style */
/* eslint-disable no-template-curly-in-string */

const htmlContent: string = "<!DOCTYPE html>\n<html lang=\"en\" style=\"width: 100%; height: 100%\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" />\n    <title>Webview Panel Container</title>\n  </head>\n  <script>\n    // | REPLACE_BY_CHANNEL_ID |\n  </script>\n\n  <script>\"use strict\";\n(() => {\n  // src/webview-host/web-iframe-channel.ts\n  var WebIframeChannel = class {\n    constructor(getId) {\n      this.getId = getId;\n      this.handlers = /* @__PURE__ */ new Map();\n      this.fakeLoad = false;\n      this.isInDevelopmentMode = false;\n      window.addEventListener(\"message\", (e) => {\n        if (e.data && (e.data.command === \"onmessage\" || e.data.command === \"do-update-state\")) {\n          this.postMessage(e.data.command, e.data.data);\n          return;\n        }\n        const channel = e.data.channel;\n        const handler = this.handlers.get(channel);\n        if (handler) {\n          handler(e, e.data.data);\n        } else {\n          console.log(\"no handler for \", e);\n        }\n      });\n      this.ready = new Promise((resolve) => {\n        resolve();\n      });\n      this.onMessage(\"devtools-opened\", () => {\n        this.isInDevelopmentMode = true;\n      });\n    }\n    get id() {\n      if (!this._id) {\n        this._id = this.getId?.() ?? \"\";\n      }\n      return this._id;\n    }\n    get inDev() {\n      return this.isInDevelopmentMode;\n    }\n    postMessage(channel, data) {\n      if (window.parent !== window) {\n        window.parent.postMessage({ target: this.id, channel, data }, \"*\");\n      }\n    }\n    onMessage(channel, handler) {\n      this.handlers.set(channel, handler);\n    }\n    onIframeLoaded(newFrame) {\n    }\n    onKeydown(event) {\n      if (event.key === \"s\" && (event.metaKey || event.ctrlKey)) {\n        event.preventDefault();\n      }\n    }\n  };\n\n  // src/webview-host/common.ts\n  var defaultCss = `body {\n  background-color: var(--vscode-editor-background);\n  color: var(--vscode-editor-foreground);\n  font-family: var(--vscode-font-family);\n  font-weight: var(--vscode-font-weight);\n  font-size: var(--vscode-font-size);\n  margin: 0;\n  padding: 0 20px;\n}\n\nimg {\n  max-width: 100%;\n  max-height: 100%;\n}\n\na {\n  color: var(--vscode-textLink-foreground);\n}\n\na:hover {\n  color: var(--vscode-textLink-activeForeground);\n}\n\na:focus,\ninput:focus,\nselect:focus,\ntextarea:focus {\n  outline: 1px solid -webkit-focus-ring-color;\n  outline-offset: -1px;\n}\n\ncode {\n  color: var(--vscode-textPreformat-foreground);\n}\n\nblockquote {\n  background: var(--vscode-textBlockQuote-background);\n  border-color: var(--vscode-textBlockQuote-border);\n}\n\n::-webkit-scrollbar {\n  width: 10px;\n  height: 10px;\n}\n\n::-webkit-scrollbar-thumb {\n  background-color: var(--vscode-scrollbarSlider-background);\n}\n::-webkit-scrollbar-thumb:hover {\n  background-color: var(--vscode-scrollbarSlider-hoverBackground);\n}\n::-webkit-scrollbar-thumb:active {\n  background-color: var(--vscode-scrollbarSlider-activeBackground);\n}\n::-webkit-scrollbar-corner {\n  background: transparent;\n}`;\n  function addslashes(str) {\n    return (str + \"\").replace(/[\\\\\"']/g, \"\\\\<!-- | REPLACE_BY_SCRIPT_TAG | -->\").replace(/\\u0000/g, \"\\\\0\");\n  }\n  function getVsCodeApiScript(state) {\n    return `\n    const acquireVsCodeApi = (function() {\n      const originalPostMessage = window.parent.postMessage.bind(window.parent);\n      const targetOrigin = '*';\n      let acquired = false;\n\n      let state = ${state ? `JSON.parse(\"${addslashes(JSON.stringify(state))}\")` : void 0};\n\n      return () => {\n        if (acquired) {\n          throw new Error('An instance of the VS Code API has already been acquired');\n        }\n        acquired = true;\n        return Object.freeze({\n          postMessage: function(msg) {\n            return originalPostMessage({ command: 'onmessage', data: msg }, targetOrigin);\n          },\n          setState: function(newState) {\n            state = newState;\n            originalPostMessage({ command: 'do-update-state', data: JSON.parse(JSON.stringify(newState)) }, targetOrigin);\n            return newState;\n          },\n          getState: function() {\n            return state;\n          }\n        });\n      };\n    })();\n    delete window.parent;\n    delete window.top;\n    delete window.frameElement;\n    window.acquireVsCodeApi = acquireVsCodeApi;\n  `;\n  }\n\n  // src/webview-host/webview-manager.ts\n  var WebviewPanelManager = class {\n    constructor(channel) {\n      this.channel = channel;\n      this.activeTheme = \"default\";\n      this.isHandlingScroll = false;\n      this.updateId = 0;\n      this.firstLoad = true;\n      this.pendingMessages = [];\n      document.addEventListener(\"DOMContentLoaded\", this.init.bind(this));\n    }\n    get ID() {\n      return this.channel.id;\n    }\n    init() {\n      if (!document.body) {\n        return;\n      }\n      this.channel.onMessage(\"styles\", (_event, data) => {\n        this.styles = data.styles;\n        this.activeTheme = data.activeTheme;\n        const target = this.getActiveFrame();\n        if (!target) {\n          return;\n        }\n        if (target.contentDocument) {\n          this.applyStyles(target.contentDocument, target.contentDocument.body);\n        }\n      });\n      this.channel.onMessage(\"focus\", () => {\n        const target = this.getActiveFrame();\n        if (target && target.contentWindow) {\n          target.contentWindow.focus();\n        }\n      });\n      this.channel.onMessage(\"content\", async (_event, data) => this.setContent(data));\n      this.channel.onMessage(\"message\", (_event, data) => {\n        const pending = this.getPendingFrame();\n        if (!pending) {\n          const target = this.getActiveFrame();\n          if (target) {\n            target.contentWindow?.postMessage(data, \"*\");\n            return;\n          }\n        }\n        this.pendingMessages.push(data);\n      });\n      this.trackFocus({\n        onFocus: () => this.channel.postMessage(\"did-focus\"),\n        onBlur: () => this.channel.postMessage(\"did-blur\")\n      });\n      this.channel.postMessage(\"webview-ready\", {});\n    }\n    async setContent(data) {\n      const currentUpdateId = ++this.updateId;\n      await this.channel.ready;\n      if (currentUpdateId !== this.updateId) {\n        return;\n      }\n      const options = data.options;\n      const newDocument = this.toContentHtml(data);\n      const frame = this.getActiveFrame();\n      const wasFirstLoad = this.firstLoad;\n      let setInitialScrollPosition;\n      if (this.firstLoad) {\n        this.firstLoad = false;\n        setInitialScrollPosition = (body, window2) => {\n          if (!isNaN(this.initialScrollProgress)) {\n            if (window2.scrollY === 0) {\n              window2.scroll(0, body.clientHeight * this.initialScrollProgress);\n            }\n          }\n        };\n      } else {\n        const scrollY = frame && frame.contentDocument && frame.contentDocument.body ? frame.contentWindow?.scrollY : 0;\n        setInitialScrollPosition = (body, window2) => {\n          if (window2.scrollY === 0) {\n            window2.scroll(0, scrollY);\n          }\n        };\n      }\n      const previousPendingFrame = this.getPendingFrame();\n      if (previousPendingFrame) {\n        previousPendingFrame.setAttribute(\"id\", \"\");\n        document.body.removeChild(previousPendingFrame);\n      }\n      if (!wasFirstLoad) {\n        this.pendingMessages = [];\n      }\n      const newFrame = document.createElement(\"iframe\");\n      newFrame.setAttribute(\"id\", \"pending-frame\");\n      newFrame.setAttribute(\"frameborder\", \"0\");\n      newFrame.setAttribute(\"allow\", \"autoplay; clipboard-read; clipboard-write;\");\n      const sandboxRules = /* @__PURE__ */ new Set([\"allow-same-origin\", \"allow-pointer-lock\"]);\n      if (options.allowScripts) {\n        sandboxRules.add(\"allow-scripts\");\n        sandboxRules.add(\"allow-downloads\");\n      }\n      if (options.allowForms) {\n        sandboxRules.add(\"allow-forms\");\n      }\n      newFrame.setAttribute(\"sandbox\", Array.from(sandboxRules).join(\" \"));\n      if (this.channel.fakeLoad) {\n        newFrame.src = `./fake.html?id=${this.ID}`;\n      }\n      newFrame.style.cssText = \"display: block; margin: 0; overflow: hidden; position: absolute; width: 100%; height: 100%; visibility: hidden\";\n      document.body.appendChild(newFrame);\n      if (!this.channel.fakeLoad) {\n        newFrame.contentDocument?.open();\n      }\n      newFrame.contentWindow?.addEventListener(\"keydown\", this.handleInnerKeydown.bind(this));\n      newFrame.contentWindow?.addEventListener(\"DOMContentLoaded\", (e) => {\n        if (this.channel.fakeLoad) {\n          newFrame.contentDocument?.open();\n          newFrame.contentDocument?.write(newDocument);\n          newFrame.contentDocument?.close();\n          hookupOnLoadHandlers(newFrame);\n        }\n        const contentDocument = e.target ? e.target : void 0;\n        if (contentDocument) {\n          this.applyStyles(contentDocument, contentDocument.body);\n        }\n      });\n      const onLoad = (contentDocument, contentWindow) => {\n        if (contentDocument && contentDocument.body) {\n          setInitialScrollPosition(contentDocument.body, contentWindow);\n        }\n        const newFrame2 = this.getPendingFrame();\n        if (newFrame2 && newFrame2.contentDocument && newFrame2.contentDocument === contentDocument) {\n          const oldActiveFrame = this.getActiveFrame();\n          if (oldActiveFrame) {\n            document.body.removeChild(oldActiveFrame);\n          }\n          this.applyStyles(newFrame2.contentDocument, newFrame2.contentDocument.body);\n          newFrame2.setAttribute(\"id\", \"active-frame\");\n          newFrame2.style.visibility = \"visible\";\n          if (this.channel.focusIframeOnCreate) {\n            newFrame2.contentWindow?.focus();\n          }\n          contentWindow.addEventListener(\"scroll\", this.handleInnerScroll.bind(this));\n          this.pendingMessages.forEach((data2) => {\n            contentWindow.postMessage(data2, \"*\");\n          });\n          this.pendingMessages = [];\n        }\n      };\n      const hookupOnLoadHandlers = (newFrame2) => {\n        clearTimeout(this.loadTimeout);\n        this.loadTimeout = void 0;\n        this.loadTimeout = setTimeout(() => {\n          clearTimeout(this.loadTimeout);\n          this.loadTimeout = void 0;\n          onLoad(newFrame2.contentDocument, newFrame2.contentWindow);\n        }, 1e3);\n        const _this = this;\n        newFrame2.contentWindow.addEventListener(\"load\", function(e) {\n          if (_this.loadTimeout) {\n            clearTimeout(_this.loadTimeout);\n            _this.loadTimeout = void 0;\n            onLoad(e.target, this);\n          }\n        });\n        newFrame2.contentWindow.addEventListener(\"click\", this.handleInnerClick.bind(this));\n        if (this.channel.onIframeLoaded) {\n          this.channel.onIframeLoaded(newFrame2);\n        }\n      };\n      if (!this.channel.fakeLoad) {\n        hookupOnLoadHandlers(newFrame);\n      }\n      if (!this.channel.fakeLoad) {\n        newFrame.contentDocument?.write(newDocument);\n        newFrame.contentDocument?.close();\n      }\n      this.channel.postMessage(\"did-set-content\", void 0);\n    }\n    trackFocus({ onFocus, onBlur }) {\n      const interval = 50;\n      let isFocused = document.hasFocus();\n      setInterval(() => {\n        const isCurrentlyFocused = document.hasFocus();\n        if (isCurrentlyFocused === isFocused) {\n          return;\n        }\n        isFocused = isCurrentlyFocused;\n        if (isCurrentlyFocused) {\n          onFocus();\n        } else {\n          onBlur();\n        }\n      }, interval);\n    }\n    getActiveFrame() {\n      return document.getElementById(\"active-frame\");\n    }\n    getPendingFrame() {\n      return document.getElementById(\"pending-frame\");\n    }\n    get defaultCssRules() {\n      return defaultCss;\n    }\n    applyStyles(document2, body) {\n      if (!document2) {\n        return;\n      }\n      if (body) {\n        body.classList.remove(\"vscode-light\", \"vscode-dark\", \"vscode-high-contrast\");\n        body.classList.add(this.activeTheme);\n      }\n      if (this.styles) {\n        for (const variable of Object.keys(this.styles)) {\n          document2.documentElement.style.setProperty(`--${variable}`, this.styles[variable]);\n        }\n      }\n    }\n    handleInnerClick(event) {\n      if (!event || !event.view || !event.view.document) {\n        return;\n      }\n      const baseElement = event.view.document.getElementsByTagName(\"base\")[0];\n      let node = event.target;\n      while (node) {\n        if (node.tagName && node.tagName.toLowerCase() === \"a\" && node.href) {\n          if (node.getAttribute(\"href\") === \"#\") {\n            event.view.scrollTo(0, 0);\n          } else if (node.hash && (node.getAttribute(\"href\") === node.hash || baseElement && node.href.indexOf(baseElement.href) >= 0)) {\n            const scrollTarget = event.view.document.getElementById(node.hash.substr(1, node.hash.length - 1));\n            if (scrollTarget) {\n              scrollTarget.scrollIntoView();\n            }\n          } else {\n            this.channel.postMessage(\"did-click-link\", node.href.baseVal || node.href);\n          }\n          event.preventDefault();\n          break;\n        }\n        node = node.parentNode;\n      }\n    }\n    handleInnerKeydown(e) {\n      this.channel.postMessage(\"did-keydown\", {\n        key: e.key,\n        keyCode: e.keyCode,\n        code: e.code,\n        shiftKey: e.shiftKey,\n        altKey: e.altKey,\n        ctrlKey: e.ctrlKey,\n        metaKey: e.metaKey,\n        repeat: e.repeat\n      });\n      this.channel.onKeydown && this.channel.onKeydown(e);\n    }\n    handleInnerScroll(event) {\n      if (!event.target || !event.target.body) {\n        return;\n      }\n      if (this.isHandlingScroll) {\n        return;\n      }\n      const progress = event.currentTarget.scrollY / event.target.body.clientHeight;\n      if (isNaN(progress)) {\n        return;\n      }\n      this.isHandlingScroll = true;\n      window.requestAnimationFrame(() => {\n        try {\n          this.channel.postMessage(\"did-scroll\", progress);\n        } catch (e) {\n        }\n        this.isHandlingScroll = false;\n      });\n    }\n    toContentHtml(data) {\n      const options = data.options;\n      const text = data.contents;\n      const newDocument = new DOMParser().parseFromString(text, \"text/html\");\n      newDocument.querySelectorAll(\"a\").forEach((a) => {\n        if (!a.title) {\n          a.title = a.getAttribute(\"href\");\n        }\n      });\n      if (options.allowScripts) {\n        const defaultScript = newDocument.createElement(\"script\");\n        defaultScript.textContent = getVsCodeApiScript(data.state);\n        newDocument.head.prepend(defaultScript);\n      }\n      const defaultStyles = newDocument.createElement(\"style\");\n      defaultStyles.id = \"_defaultStyles\";\n      defaultStyles.innerHTML = this.defaultCssRules;\n      newDocument.head.prepend(defaultStyles);\n      this.applyStyles(newDocument, newDocument.body);\n      return \"<!DOCTYPE html>\\n\" + newDocument.documentElement.outerHTML;\n    }\n  };\n\n  // src/webview-host/web-preload-builtin.ts\n  new WebviewPanelManager(new WebIframeChannel(() => window.channelId));\n})();\n</script>\n\n  <body style=\"margin: 0; overflow: hidden; width: 100%; height: 100%\"></body>\n</html>\n";

export const createHTML = (channelId: string) => {
  const text = 'window.channelId = ' + JSON.stringify(channelId) + ';';
  return htmlContent.replace('// | REPLACE_BY_CHANNEL_ID |', text);
};
